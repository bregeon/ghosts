import math
import numpy as np
import pandas as pd
from ghosts.tweak_optics import rotate_optic, make_optics_reflective, translate_optic, randomized_telescope
from ghosts.beam_configs import BEAM_CONFIG_0, BEAM_CONFIG_1
from ghosts.beam import beam
from ghosts.analysis import reduce_ghosts, make_data_frame, compute_ghost_separations


# run a ray tracing simulation
def run_simulation(telescope_setup, beam_config=BEAM_CONFIG_0):
    """ Runs a ray tracing simulation of a light beam into the CCOB.

    Takes a telescope optical object and a beam configuration as a dictionary,
    simulates the light beam through the optics and returns the full ray tracing,
    including ghosts and the beam as a vector of light ays

    Parameters
    ----------
    telescope_setup : `batoid.telescope`
        the optical setup
    beam_config : `dict`
        a dictionary with the light beam configuration, see :ref:`beam_configs`.

    Returns
    -------
    trace_full : `OrderedDict of dict`
        an ordered dictionary of dictionaries for incoming and outgoing rays for each optics interface,
        see `batoid.optic.traceFull`
    forward_rays : `list` of `batoid.RayVector`
        a list of forward rays, as each item in list comes from one distinct path through the optic exiting in
        the forward direction.  see `batoid.optic.traceSplit`
    reverse_rays : `list` of `batoid.RayVector`
        the list of reverse rays, as each item in list comes from one distinct path through the optic exiting
        in the reverse direction., see `batoid.optic.traceSplit`
    rays : `batoid.RayVector`
        the input light beam, generated by the `beam` functions see :meth:`ghosts.beam.beam`.
    """
    # Beam On
    rays = beam(beam_config)
    # Trace full optics and plot on the camera system
    forward_rays, reverse_rays = telescope_setup.traceSplit(rays, minFlux=1e-4)
    trace_full = telescope_setup.traceFull(rays)
    return trace_full, forward_rays, reverse_rays, rays


# Rotate and simulate
def full_rotation(telescope, optic_name='L2', axis='y', angle=0.1, beam_config=BEAM_CONFIG_1, debug=False):
    """ Runs a ray tracing simulation of a light beam into the CCOB with one of the optical element rotated.

    Takes a telescope optical object, the name of an optical element and a rotation angle, and
    simulates the light beam through the optics and returns the full ray tracing,
    including ghosts and the beam as a vector of light ays

    Parameters
    ----------
    telescope : `batoid.telescope`
        the optical setup as defined in `batoid`
    optic_name : `string`
        the name of the optical element to rotate
    axis : `string`
        x, y, z as the rotation axis you wish
    angle : `float`
        the rotation angle in degrees
    beam_config : `dict`
        a dictionary with the light beam configuration, see :ref:`beam_configs`.
    debug : `bool`
        debug mode or not

    Returns
    -------
    spots_data_frame : `pandas.DataFrame`
        a pandas data frame with ghost spot data information, including beam configuration,
        see :meth:`ghosts.analysis.make_data_frame`
    ghost_separations : `pandas.DataFrame`
        a pandas data frame with information on ghost spots data separations and ratios,
        see :meth:`ghosts.analysis.compute_ghost_separations`
    """
    rotated_optic = rotate_optic(telescope, optic_name, axis=axis, angle=angle)
    if debug:
        print(
            f'{optic_name} rotation of {angle:.3f}Â° means a displacement of'
            f' {300 * math.tan(angle * math.pi / 180.):.3f}\
             mm of the lens border.')
    make_optics_reflective(rotated_optic)
    trace_full, r_forward, r_reverse, rays = run_simulation(rotated_optic, beam_config)
    spots_data, _spots = reduce_ghosts(r_forward)
    spots_data_frame = make_data_frame(spots_data, beam_config)
    ghost_separations = compute_ghost_separations(spots_data_frame)
    return spots_data_frame, ghost_separations


# Rotating L2 specifically
def full_rotation_L2(telescope, angle=0.1):
    """ Simple proxy to run a simulation with a rotation of L2, see :meth:`ghosts.simulator.full_rotation`

    Parameters
    ----------
    telescope : `batoid.telescope`
        the optical setup as defined in `batoid`
    angle : `float`
        the rotation angle in degrees

    Returns
    -------
    spots_data_frame : `pandas.DataFrame`
        a pandas data frame with ghost spot data information, including beam configuration,
        see :meth:`ghosts.analysis.make_data_frame`
    ghost_separations : `pandas.DataFrame`
        a pandas data frame with information on ghost spots data separations and ratios,
        see :meth:`ghosts.analysis.compute_ghost_separations`
    """
    return full_rotation(telescope, optic_name='L2', angle=angle)


def sim_scan_rotated_optic(telescope, optic_name, min_angle, max_angle, step_angle, ref_data_frame):
    """ Helper to run and plot a scan in one optical element rotation

    .. todo::
        `sim_scan_rotated_optic` should handle better reference data frame

    Parameters
    ----------
    telescope : `batoid.telescope`
        the optical setup as defined in `batoid`
    optic_name : `string`
        the name of the optical element to rotate
    min_angle : `float`
        the first rotation angle in degrees
    max_angle : `float`
        the last rotation angle in degrees
    step_angle : `float`
        the angle step size for the rotation in degrees
    ref_data_frame : `pandas.DataFrame`

    Returns
    -------
    merged_data_frame : `pandas.DataFrame`
        a pandas data frame with all the ghosts spot data information, for each telescope optics configuration,
        including beam configuration, see :meth:`ghosts.analysis.make_data_frame`
    scan_angles : `list` of `floats`
        the list of the rotation angles used for the scan
    """
    print(f'Starting {optic_name} rotation scan.')
    rotation_sims = list()
    scan_angles = list()
    for angle in np.arange(min_angle, max_angle, step_angle):
        scan_angles.append(angle)
        print(f'{angle:.3f}', end=' ')
        df, _ = full_rotation(telescope, optic_name=optic_name, angle=angle)
        rotation_sims.append(df)

    # Merge data frames
    merged_data_frame = [pd.merge(ref_data_frame, df, how='left', on='name') for df in rotation_sims]
    print('Done.')
    return merged_data_frame, scan_angles


# Translate and simulate
def full_translation(telescope, optic_name='L2', distance=0.01):
    """ Runs a ray tracing simulation of a light beam into the CCOB, with one optical element translated.

    Takes a telescope optical object, the name of an optical element, and a translation distance,
    simulates the light beam through the optics and returns the full ray tracing,
    including ghosts and the beam as a vector of light ays

    .. todo::
        `full_translation` should take the rotation axis and the beam config as an input paramters

    Parameters
    ----------
    telescope : `batoid.telescope`
        the optical setup as defined in `batoid`
    optic_name : `string`
        the name of the optical element to rotate
    distance : `float`
        the distance in meters

    Returns
    -------
    spots_data_frame : `pandas.DataFrame`
        a pandas data frame with ghost spot data information, including beam configuration,
        see :meth:`ghosts.analysis.make_data_frame`
    ghost_separations : `pandas.DataFrame`
        a pandas data frame with information on ghost spots data separations and ratios,
        see :meth:`ghosts.analysis.compute_ghost_separations`
    """
    translated_optic = translate_optic(telescope, optic_name, axis='x', distance=distance)
    make_optics_reflective(translated_optic)
    trace_full, forward_rays, reverse_rays, rays = run_simulation(translated_optic, beam_config=BEAM_CONFIG_0)
    spots_data, _spots = reduce_ghosts(forward_rays)
    spots_data_frame = make_data_frame(spots_data)
    ghost_separations = compute_ghost_separations(spots_data_frame)
    return spots_data_frame, ghost_separations


# Helpers to run and plot a scan in one optical element translation
def sim_scan_translated_optic(telescope, optic_name, min_dist, max_dist, step_dist, ref_data_frame):
    """ Helper to run a set of ray tracing simulation of a light beam into the CCOB,
     with one optical element translated along one axis of a set of difference distance

    Takes a telescope optical object, the name of an optical element, and a range for the translation distances,
    simulates the light beam through the optics and returns the full ray tracing,
    including ghosts and the beam as a vector of light ays

    .. todo::
        `sim_scan_translated_optic` needs to better handle the reference data frame

    .. todo::
        `sim_scan_translated_optic` should take a list of distances rather than min, max, step

    Parameters
    ----------
    telescope : `batoid.telescope`
        the optical setup as defined in `batoid`
    optic_name : `string`
        the name of the optical element to rotate
    min_dist : `float`
        the start distance in meters
    max_dist : `float`
        the stop distance in meters
    step_dist : `float`
        the step size as a distance in meters
    ref_data_frame : `pandas.dataFrame`
        a data frame with your ghosts spots reference data

    Returns
    -------
    merged_data_frame : `pandas.DataFrame`
        a pandas data frame with all the ghosts spot data information, for each telescope optics configuration,
        including beam configuration, see :meth:`ghosts.analysis.make_data_frame`
    scan_values : `list` of `floats`
        the list of distance of translation used for the scan
    """
    print(f'Starting {optic_name} translation scan.')
    sims = list()
    scan_values = list()
    for shift in np.arange(min_dist, max_dist, step_dist):
        scan_values.append(shift)
        print(f'{shift:.6f}', end=' ')
        df, _ = full_translation(telescope, optic_name=optic_name, distance=shift)
        sims.append(df)

    # Merge data frames
    merged_data_frame = [pd.merge(ref_data_frame, df, how='left', on='name') for df in sims]
    print('Done.')
    return merged_data_frame, scan_values


def full_random_telescope_sim(telescope, max_angle, max_shift, beam_config=BEAM_CONFIG_0):
    """ Runs a ray tracing simulation of a light beam into the CCOB, with optics with randomized positions
     and rotation angles.

    Takes a telescope optical object, the maximum value of the rotation angle and translation distance, and the
    beam configuration dictionary. Random distributions for the angle and distance are uniform.

    Parameters
    ----------
    telescope : `batoid.telescope`
        the optical setup as defined in `batoid`
    max_angle : `float`
        the maximum value of the rotation angle, a value will be taken out of a uniform distribution in
        [-max_angle ; +max_angle]
    max_shift : `float`
        the maximum value of the translation distance, a value will be taken out of a uniform distribution in
        [-max_shift ; +max_shift]
    beam_config : `dict`
        a beam configuration dictionary

    Returns
    -------
    spots_data_frame : `pandas.DataFrame`
        a pandas data frame with ghost spot data information, including beam configuration,
        see :meth:`ghosts.analysis.make_data_frame`
    ghost_separations : `pandas.DataFrame`
        a pandas data frame with information on ghost spots data separations and ratios,
        see :meth:`ghosts.analysis.compute_ghost_separations`
    """
    rnd_tel = randomized_telescope(telescope, max_angle, max_shift)
    make_optics_reflective(rnd_tel)
    trace_full_r, r_forward_r, r_reverse_r, rays_r = run_simulation(rnd_tel, beam_config=beam_config)
    spots_data_r, _spots = reduce_ghosts(r_forward_r)
    data_frame_r = make_data_frame(spots_data_r)
    ghost_separations_r = compute_ghost_separations(data_frame_r)
    return data_frame_r, ghost_separations_r
